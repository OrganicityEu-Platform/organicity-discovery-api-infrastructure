# Add elastic search, logstash and kibana

# service configuration for Redis
redis:
  image: redis:latest
  hostname: redis1
  restart: unless-stopped
  ports:
    - "6379:6379"

# service configuration for Postgres
db:
  image: mdillon/postgis
  # use the preferred version of the official Postgres image
  # see https://hub.docker.com/_/postgres/
  # persist the database between containers by storing it in a volume
  restart: unless-stopped
  volumes:
    - oraganicityapi-postgres:/var/lib/postgresql/data

mongo:
  build: .
  # sources environment variable configuration for our app, required for the mongo tunnel
  env_file: .env
  # build with a different Dockerfile
  dockerfile: containers/Dockerfile-mongo
  restart: unless-stopped
  volumes:
    - ./scripts:/scripts
    - .:/organicity-discovery-api
    - ./organicity-discovery-api/tmp:/tmp
  # Expose port only within docker
  ports:
    - "3344:3344"
  command: bash -c "/scripts/tunnel.sh"

# service configuration for our dockerized Rails app
app:
  # use the Dockerfile next to this file
  build: .
  dockerfile: organicity-discovery-api/Dockerfile
  # sources environment variable configuration for our app
  env_file: .env
  # rely on the RAILS_ENV value of the host machine
  volumes:
    - ./organicity-discovery-api:/organicity-discovery-api
    - ./organicity-discovery-api/tmp:/tmp
    - ./scripts:/scripts
    - ./config:/config
  # makes the app container aware of the DB container
  links:
    - db
    - redis
    - mongo
  restart: unless-stopped
  # expose the port we configured Puma to bind to (should expose only internally)
  ports:
    - "3000:3000"
  command: bash -c "/scripts/startup.sh"

worker:
  build: .
  # Worker is just a rails app like the 'app' running sidekiq, so they share Dockerfile
  dockerfile: organicity-discovery-api/Dockerfile
  volumes_from:
    - app
  env_file: .env
  links:
    - app
    - mongo
    - db
    - redis
  restart: unless-stopped
  command: bash -c "/scripts/sidekiq.sh"

# spring:
#   build: .
#   volumes:
#     - .:/organicity-discovery-api
#   links:
#     - app
#   command: spring server
#
#   # This ensures that the pid namespace is shared between the host
#   # and the container. It's not necessary to be able to run spring
#   # commands, but it is necessary for "spring status" and "spring stop"
#   # to work properly.
#   pid: host

# service configuration for our web server
web:
  image: steveltn/https-portal:1
  links:
    - app
      #- recommender
  env_file: .env
  environment:
    #DOMAINS: 'discovery.organicity.eu -> http://app:3000'
    DOMAINS: "${MY_DOMAIN}"  # Takes value from .env file
    STAGE: "${MY_STAGE}"
  restart: unless-stopped
  ports:
    - 80:80
    - 443:443
  volumes:
    - ./config/cors.conf:/etc/nginx/cors.conf
    - ./config/shared.conf:/etc/nginx/shared.conf
    - ./config/upstream.conf:/etc/nginx/conf.d/upstream.conf
      # These files must go in /var/lib/nginx-conf where the erb values are converted
      # Either create a specific site:
      #- ./config/default.conf.erb:/var/lib/nginx-conf/discovery.organicity.eu.conf.erb:ro
      #- ./config/default.ssl.conf.erb:/var/lib/nginx-conf/discovery.organicity.eu.ssl.conf.erb:ro
      # OR overwrite the defaults
    - ./config/default.conf.erb:/var/lib/nginx-conf/default.conf.erb:ro
    - ./config/default.ssl.conf.erb:/var/lib/nginx-conf/default.ssl.conf.erb:ro

# Prediction.io recommender (loaded from a submodule)
#recommender:
#  build: organicity-recommender
#  env_file: .env
#  ports:
#    - 7070:7070
#    - 8000:8000

